
/*
 *
 * CS-252 Fall 2017
 * shell.l: lexical analyzer for shell
 * You have to extend it.
 *
 */

%{
#include <string.h>
#include <sys/wait.h>
#include <cstring>
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include "y.tab.hh"

static  void yyunput (int c,char *buf_ptr  );

void myunputc(int c) {
  unput(c);
}

%}

%%

\n {
  return NEWLINE;
}

[ \t] {
  /* Discard spaces and tabs */
}

">" {
  return GREAT;
}

">>" {
	return GREATGREAT;
}

"<" {
	return LESS;
}

"&" {
	return AMPERSAND;
}

">&" {
	return GREATAMPERSAND;
}

">>&" {
	return GREATGREATAMPERSAND;
}

"|" {
	return PIPE;
}

"2>" {
	return TWOGREAT;
}
`[^\n`]*`  {

                char *cmd = strdup(yytext);
		char *buffer = (char*) malloc(1024*sizeof(char*));
                int ret;

                // Save original redirects
                int defaultin = dup(0);
                int defaultout = dup(1);

		// pipes
		int pipe1[2];
		int pipe2[2];
                pipe(pipe1);
		pipe(pipe2);

		   int flags = fcntl(pipe2[0], F_GETFL);
		   fcntl(pipe2[0],F_SETFL, flags | O_NONBLOCK);

		   dup2(pipe1[1], 1); //parent out to child
		   close(pipe1[1]);
		   printf("%s\nexit2\n", cmd);

                   ret = fork();
		   if(ret == 0)
                   {

			//redirect input from parent's output
			dup2(pipe1[0], 0);
			dup2(pipe2[1], 1);

			close(pipe1[0]);
			close(pipe2[1]);

			//_exit(0);
		   }
		   else
		   {
		     // wait for child to finish
		     while(waitpid(ret, NULL, 0) == -1);

		     close(pipe1[1]);

                     // Put result into buffer
		     for(int i = 0; i < 1024; i++)
			   buffer[i] = 0;
		     
		     // read from pipe2 one char at a time
		     int count = 0;
		     while(read(pipe2[0], buffer, 1) > 0)
		     {
		     	if(*buffer == '\n')
			   *buffer = ' ';
			count++;
			buffer++;
      		     }
		     close(pipe2[1]);
		     // set buffer to &buffer[0]
		     // Make sure to null terminate 
		     buffer[count]=0;

		     // append the subshelled command to the initial command

			//dup2(defaultout, 1);	
	             //fprintf(stdout, "cmd: %s", cmd);
		     //fprintf(stdout, "count: %d\n", count);
		     //fprintf(stdout, "\nsizeof(cmd): %d\n", (int)strlen(cmd));
		     
		     // reset stdin and stdout to default
		     dup2(defaultin, 0);
		     dup2(defaultout, 1);


         	      // close
	       	      close(defaultin);
	              close(defaultout);

		      // free
		      free(subCmd); 
		      free(buffer);

		      prctl(PR_SET_PDEATHSIG, SIGHUP);

		      for(int i = (int)strlen(cmd) - 1; i >= 0; i--)
		        yyunput(cmd[i], yytext);

		     //perror("fork");
		     //_exit(0);
		   }
}


[^ \t\n][^ \t\n]*  {
  /* Assume that file names have only alpha chars */
  yylval.string_val = strdup(yytext);
  return WORD;
}

["][^"]*["] {
  yylval.string_val = strdup(yytext+1);
  yylval.string_val[yyleng-2] = '\0';
  return WORD;
}

[^ ^\\&<>|\t\n][^ ^\\&<>|\t\n]* {
	yylval.string_val = strdup(yytext);
	return WORD;
}
